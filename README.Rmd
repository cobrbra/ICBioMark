---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ICBioMark

<!-- badges: start -->
<!-- badges: end -->

Welcome to ICBioMark, based on the paper "Data-driven design of targeted gene panels forestimating immunotherapy biomarkers", *Bradley and Cannings* (currently being written [here](https://github.com/cobrbra/TargetedPanelEstimation_Paper)). ICBioMark is designed to implement regularised optimisation methods for the design and use of targeted gene panels in predicting immunotherapeutic biomarkers such as Tumour Mutation Burden (TMB) and Tumour Indel Burden (TIB).

## Installation

<!-- You can install the development version of ICBioMark from [CRAN](https://CRAN.R-project.org) with: -->
You can install the development version of this package from this github repository (using the [devtools](https://cran.r-project.org/web/packages/devtools/index.html) package) with:

``` {r eval = FALSE}
devtools::install_github("cobrbra/ICBioMark")
```

## Example Workflow

Upon installation we can load the package.

```{r example}
library(ICBioMark)
```

To demonstrate the typical workflow for using ICBioMark, we play around with a small and friendly example dataset. This is pre-loaded with the package, but just comes from the data simulation function `generate_maf_data()`, so you can play around with datasets of different sizes and shapes. 

### Input Data

Our example dataset, called `example_maf_data`, is a list with two elements: `maf` and `gene_lengths`. These are the two pieces of data that you'll always need to use this package, and they look as follows:

 * `maf` is a data frame in the MAF (mutation annotated format) style. For a set of sequenced tumour/normal pairs, this means a table with a row for every mutation identified, with columns corresponding to properties such as the sample ID for the tumour of origin, the gene, chromosome and nucelotide location of the mutation, and the type of mutation observed. In the real world, MAF datasets often have lots of extra information beyond this, but in our small example we've just included sample, gene and mutation type (it's all we'll need!). The top five rows look like this:
 
```{r example_maf}
 # example_maf_data <- generate_maf_data()

 kable(head(example_maf_data$maf, 5), row.names = FALSE)
```
 * `gene_lengths`, another data frame, this time containing the names of genes that you'll want to include in your modelling and their length. Gene length is a complex and subtle thing to define - we advise using coding length as defined in the [Ensembl](https://www.ensembl.org/index.html) database. For this example, however, gene lengths are again randomly chosen:
 
``` {r example_gene_lengths}
  kable(head(example_maf_data$gene_lengths, 5), row.names = FALSE)
```
These are the only two bits of data required to use ICBioMark. Your gene lengths data can contain values for far more genes than are observed in your dataset, and it's not a huge problem if a couple of genes in a Whole-Exome Sequencing (WES) experiment are missing gene length information, but lots of missing values will cause issues with your model accuracy. Later versions of this package should be able to address missing gene length data.

### Train/Val/Test and Matrix Construction
The MAF format is widely used and standardised, but not espeically helpful for our purposes. The ideal format for our data is a matrix, where every row corresponds to a sample, every column corresponds to a gene/mutation type combination, and each entry corresponds to how many mutations of that sample, gene and type were sequenced. At the same time as this, we'd like to separate our training data from separately reserved validation and test data. We do this using the function `get_mutation_tables()`. 

Before we do this, however, we need to talk about mutation types. Our procedure models different mutation types separately, so in theory one could have separate parameters for each mutation type (e.g. 'Missense_Mutation' or 'Silent'). However, doing so will vastly increase the computational complexity of fitting a generative model. It is also not particularly informative to fit parameters to extremely scarce mutation types. We therefore group mutation types together (and can filter some out if we don't want to include them in our modelling). This will happen behind-the-scenes, but is worth knowing about to understand the outputs generated. Mutations types are grouped and filtered by the function `get_mutation_dictionary()`. In general we recommend separately modelling indel mutations (so that we can predict TIB later), synonymous mutations (as these don't count towards TMB or TIB), and lumping together all other nonsynonymous mutation types. The function `get_mutation_dictionary()` produces a list of mutation types, with labels for their groupings. For example:

```{r example_mutation_dictionary}
  kable(get_mutation_dictionary(), col.names = "Label")
```
We've given each mutation type one of three labels: "NS", "S" and "I". We could have excluded synonymous mutation types by using `get_mutation_dictionary(include_synonymous = FALSE)`.

Now we can produce our training, validation and test sets (again for this example workflow these are pre-loaded). The object produced has three elements: 'train', 'val' and 'test'. Each of these contains a sparse mutation matrix ('matrix') and other information describing the contents of the matrix ('sample_list', 'gene_list', 'mut_types_list' and 'col_names'). We can see that the list of mutation types contains the three labels we specified above

```{r example_tables_1}
  #example_tables <- get_mutation_tables(example_maf_data$maf, 
  #                   sample_list = paste0("SAMPLE_", 1:100))

  print(example_tables$train$mut_types_list)
```
and that the columns of each matrix correspond to each combination of mutation type and gene:

```{r example_tables_2}
  print(head(example_tables$train$col_names, 10))
```


### Fitting the Generative Model
There are relatively few decisions left to be made at this point: all we need to do to fit a generative model is to provide gene lengths data and training data to the function `fit_gen_model()`. We can visualise output of our model with `vis_model_fit()`.

```{r example_gen_model}
  # example_gen_model <- fit_gen_model(example_maf_data$gene_lengths, 
  #                       table = example_tables$train)

  print(vis_model_fit(example_gen_model))

```

Since this is a small example, we don't get a particularly strong signal, but we do see an optimum level of penalisation. (NB: the function `vis_model_fit()` essentially performs the same task as `glmnet::plot.cv.glmnet()`. In later versions the `glmnet` version will hopefully be directly applicable and `vis_model_fit()` will be redundant).

### Fitting the Predictive Model

### Making Predictions 

### Analysing Performance

## Getting Help
Please do feel free to flag issues and requests on this repository. In dire need, you can try reaching me by [email](j.r.j.bradley@sms.ed.ac.uk), but I make no guarantees on speedy response via this route.


What is special about using `README.Rmd` instead of just `README.md`? You can include R chunks like so:

```{r cars}
summary(cars)
```

You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date.

You can also embed plots, for example:

```{r pressure, echo = FALSE}
plot(pressure)
```

In that case, don't forget to commit and push the resulting figure files, so they display on GitHub!
